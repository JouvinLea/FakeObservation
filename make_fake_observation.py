#! /usr/bin/env python
import sys
from gammapy.data import DataStore
import logging
import subprocess
import os
from astropy.coordinates import SkyCoord,Angle
import shutil
import hashlib
from pathlib2 import Path
import click
import numpy as np
from astropy.io import fits
from astropy.table import Table, QTable, vstack
from astropy.table import join
from astropy.time import Time
import os
import argparse
import FrenchMcBands
from astropy.units import Quantity
from random import *
from astropy.io.fits import table_to_hdu
from astropy.io import fits
import math
from astropy.table import Column

#argument: config, prog,number of fake observation, spectral law: PWL ou EXP, if PWL precise the spectral index you want for the MC source, if EXP the spectral index and the beta (1/(energy cutoff)) you want for the MC source
#./make_fake_observation.py "ash_stereo_thsq64" "Prod15_4_stereo" 200 "PWL" 2 1000
#./make_fake_observation.py "ash_stereo_thsq64" "Prod15_4_stereo" 200 "PWL" 2.2 1000
#./make_fake_observation.py "ash_stereo_thsq64" "Prod15_4_stereo" 200 "PWL" 2.6 1000
#./make_fake_observation.py "ash_stereo_thsq64" "Prod15_4_stereo" 200 "EXP" 2.3 0.2 1000
#./make_fake_observation.py "ash_stereo_thsq64" "Prod15_4_stereo" 200 "EXP" 2 0.2 1000
#./make_fake_observation.py "ash_stereo_thsq64" "Prod15_4_stereo" 200 "EXP" 2.1 0.2 1000


class ObservationData:
    """Helper functions to compute file and folder names as it is defined for FITS data
    """

    # filetypes = ['events', 'aeff', 'edisp', 'psf_3gauss']
    filetypes = ['events']

    def __init__(self, obs_id, hap_config=None, telpattern=None):
        self.obs_id = obs_id
        self.hap_config = hap_config
        self.telpattern = telpattern

    @property
    def obs_group(self):
        obs_id_min = self.obs_id - (self.obs_id % 200)
        obs_id_max = obs_id_min + 199
        return obs_id_min, obs_id_max

    @property
    def _obs_group_folder(self):
        return Path('run{:06d}-{:06d}'.format(self.obs_group[0], self.obs_group[1]))

    @property
    def _obs_folder(self):
        return Path('run{:06d}'.format(self.obs_id))

    def folder(self, step=None):
        """Create folder for a given step.
        """
        if step is None:
            return self._obs_group_folder / self._obs_folder
        else:
            return Path(step) / self._obs_group_folder / self._obs_folder

    def hap_filename(self, filetype):
        """Name of FITS file generated by HAP"""
        if filetype == 'events':
            return self.folder('events') / 'run_{:07d}_{}_eventlist.fits'.format(self.obs_id, self.hap_config)
            # return self.folder('events') / 'events_{:06d}.fits.gz'.format(self.obs_id)
        elif filetype == 'aeff':
            return self.folder('irfs') / 'aeff_{:06d}.fits'.format(self.obs_id)
        elif filetype == 'edisp':
            return self.folder('irfs') / 'edisp_{:06d}.fits'.format(self.obs_id)
        elif filetype == 'psf_3gauss':
            return self.folder('irfs') / 'psf_3gauss_{:06d}.fits'.format(self.obs_id)
        else:
            raise ValueError('Invalid {} {}'.format(filetype))

    def out_filename(self, filetype, dir, format='old'):
        """Name of FITS file in out folder"""
        filename = self.filename(filetype=filetype, format=format)
        return Path(dir) / filename

    def filename(self, filetype, format='old'):
        if format == 'old':
            TAGS = dict(
                events='events',
                aeff='aeff_2d',
                edisp='edisp_2d',
                psf_3gauss='psf_3gauss',
                psf_king='psf_king',
                psf_table='psf_table',
                background='bkg_offruns',
            )
        elif format == 'new':
            TAGS = dict(
                events='events',
                aeff='aeff',
                edisp='edisp',
                psf_3gauss='psf_3gauss',
                psf_king='psf_king',
                psf_table='psf_table',
                background='background',
            )

        tag = TAGS[filetype]
        if (filetype == "events"):
               filename = '{}_{:06d}.fits.gz'.format(tag, self.obs_id)
        else:
            if(self.obs_id>99999):
                filename = '{}_0{:06d}.fits'.format(tag, self.obs_id)
            else:
                filename = '{}_{:06d}.fits'.format(tag, self.obs_id)
        return self.folder() / filename

    def mkdir(self, step):
        """Make directory (parts=True, exists_ok=True)"""
        path = self.folder(step)
        if not path.exists():
            path.mkdir(parents=True)

        return path

    def check_out_files_exist(self):
        """Check if all out files exist"""
        for filetype in self.filetypes:
            filename = self.out_filename(filetype)
            if not filename.is_file():
                log.error('MISSING: {}'.format(filename))
                return False

        return True

class MC:
    """Class containing the informations on the MC observational condition used in the simulation.
    1) Allow to select the appropriate MC condition depending on the observational condition of the real observational
    2) Method to create the fits file name (events, IRF) and folder name for the MC in the same way than the real FITS data
    """

    # filetypes = ['events', 'aeff', 'edisp', 'psf_3gauss']
    filetypes = ['events']

    def __init__(self):
        self.zenMC = [0, 18, 26, 32, 37, 41, 46, 50, 53, 57, 60, 63, 67, 70]
        self.effMC = [50, 60, 70, 80, 90, 100]
        self.offMC = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5]
        self.gammaMC = [2]
        self.azMC = [180,0]
        self.MCband=FrenchMcBands.FrenchMcBands(i=4,energy_type="spectrum")

    def folder(self,eff,run_number):
        return Path(str(eff)+"/run"+str(run_number))

    def out_filename(self, filetype,eff,run_number):
        """Name of FITS file in out folder"""
        filename = self.filename(filetype=filetype,eff=eff,run_number=run_number)
        # return Path(dir) / filename
        return filename

    def filename(self, filetype,eff,run_number):

        TAGS = dict(
            events='events',
            aeff='aeff_2d',
            edisp='edisp_2d',
            psf_3gauss='psf_3gauss',
            psf_king='psf_king',
            psf_table='psf_table',
            background='bkg_offruns',
        )

        tag = TAGS[filetype]

        if (filetype == "events"):
            filename = Path("run_"+str(run_number)+"_eventlist.fits")
        else:
            filename = Path(tag+'_'+str(run_number)+'.fits')

        return self.folder(eff=eff,run_number=run_number) / filename



if __name__ == '__main__':
    """
    Will create a number of directory containning the fits file (events, IRF, obs table, hdu table) for each of your fake observation
    """
    Observation=MC()
    parser = argparse.ArgumentParser(description='Make the index and obs table')
    parser.add_argument('config', action="store", help='Prod Configuration, cut we apply')
    parser.add_argument('prod', action="store", help='Prod')
    parser.add_argument('Nsimus', action="store", help='Number of faked observation we want to generate')
    parser.add_argument('loi_spectrale', action="store", help='spectral law: "PWL" or "EXP"')
    parser.add_argument('gamma_input', action="store", help='spectral index')
    if parser.parse_known_args()[0].loi_spectrale== "EXP":
        parser.add_argument('beta_input', action="store", help='Inverse of the energy cutoff if we want to simulate one in the spectrum')
    parser.add_argument('n_events_to_draw', action="store", help='Number of events to generate the fake MC source from the triggered events list')
    #Read the arguments
    arg = parser.parse_args()
    config = arg.config
    prod = arg.prod
    Nsimus = int(arg.Nsimus)
    loi_spectrale= arg.loi_spectrale
    gamma_input=float(arg.gamma_input)
    if loi_spectrale=="EXP":
         beta_input=float(arg.beta_input)
    #Directory where are located the FITS files for the MC data (indir_MC) and for the real HESS data (indir_data)
    #You have to change these variables depending on where are located your data
    indir_MC = os.path.expandvars('$CALDB')+"/"+prod+"/MC_data/"+config
    indir_data= os.path.expandvars('$CALDB')+"/"+prod+"/new_data/"+config
    #Load the obs table of HESS data
    ds_real_data=DataStore.from_dir(indir_data)
    # The run of 2155 is the 954 row of the obs table. A better way to go will be to use np.where() from the real obs id and select the matching row in the obs table...
    iobs=945
    # Read the observational condition of the real 2155 observation
    table_obs_realdata=ds_real_data.obs_table[iobs]
    obs_id=table_obs_realdata["OBS_ID"]
    RealObservation=ObservationData(obs_id)
    effobs=table_obs_realdata["MUONEFF"]*100
    zenobs=table_obs_realdata["ZEN_PNT"]
    azobs=table_obs_realdata["AZ_PNT"]
    offobs=np.sqrt((table_obs_realdata["RA_PNT"]-table_obs_realdata["RA_OBJ"])**2+(table_obs_realdata["DEC_PNT"]-table_obs_realdata["DEC_OBJ"])**2)
    # Select the closest MC obsertional condition to the previous real observational condition of the run
    effMC=Observation.effMC[np.abs(Observation.effMC-effobs).argmin()]
    zenMC=Observation.zenMC[np.abs(Observation.zenMC-zenobs).argmin()]
    offMC=Observation.offMC[np.abs(Observation.offMC-offobs).argmin()]
    azMC=Observation.azMC[np.abs(Observation.azMC-azobs).argmin()]
    gammaMC=Observation.gammaMC[0]
    #Find the MC number simulation from the selected MC osbervational condition (used the FrenchMcBands class in the second file)
    run_number=int(Observation.MCband.run_number(azMC,zenMC, offMC, gammaMC))

    #Set of different event and IRF FITS file names for the MC and for the real HESS data
    events_filename_MC = Path(indir_MC) / Observation.filename('events',effMC,run_number)
    events_filename_data = Path(indir_data) / RealObservation.filename('events', format="old")
    aeff_filename = Path(indir_MC) / Observation.filename('aeff',effMC,run_number)
    edisp_filename = Path(indir_MC) / Observation.filename('edisp',effMC,run_number)
    psf_filename = Path(indir_MC) / Observation.filename('psf_table',effMC,run_number)
    #Load the events list table for the real HESS data (table_data) and for the MC simulation (table_data_MC)
    try:
        table_data = QTable.read(str(events_filename_data), hdu=1)
    except Exception:
        print "fits corrupted for file " + str(events_filename_data)
        exit()
    try:
        table_data_MC = QTable.read(str(events_filename_MC), hdu=1)
    except Exception:
        print "fits corrupted for file " + str(events_filename_data)
        exit()

    #It's a trick to not forget!!!
    #We want to determine the whole energy range of the MC simulation to compute the integral flux for example.
    #In the table_MC_simulated (variable below), you have the number of simulated MC events in different energy bins.
    #To determine the whole range of the simulation, you cannot just take the first and last energy bins with a number of MC events different from 0.
    #Indeed, the minimum energy at which start the MC simulation is different from the lower edge of the frist bin that is non equal to zero. It is maybe at the middle, at the third, we don't know, this is not an information kept...
    #This is why I remove all the events from the first bin different from 0 and I consider for the minimum energy of the simulation the lower edge of the second bin that is not equal to zero.
    table_MC_simulated=QTable.read(str(events_filename_MC), hdu=5)
    #First bin with a number of MC events different from 0
    i_MC=np.where(table_MC_simulated["N_EVT"]>0)[0]
    #Number of simulated events in this first bin
    Nsimulated_firstbin_nonzeroevents=table_MC_simulated["N_EVT"][i_MC[0]].value
    #Total number of simulated MC events
    Ntot=table_MC_simulated["N_EVT"].sum().value
    #Here, we retrieve from the total number of MC events, the one in the frist bin
    Nsimulated=Ntot-Nsimulated_firstbin_nonzeroevents

    #Lower energy edge of the second bin with a number of events different from 0
    emin=table_MC_simulated["Ebin_MIN"][i_MC[1]]
    #Upper energy edge of the last bin with a number of events different to 0
    emax=table_MC_simulated["Ebin_MAX"][i_MC[-1]]
    #index of the energy bin of the MC simulation we use
    ikept=np.where(table_data_MC["MC_ENERGY"]>emin)
    table=table_data_MC[ikept]
    #Number of trigered events, thus after applying the cuts and algorithm of reconstruction/discrimination
    Ntrigered=len(table_data_MC)
    #Simulate a fake observation of livetime equal to the one of the real HESS observation (around 28 min)
    livetime=Quantity(table_obs_realdata["LIVETIME"],"s")
    table_MC=QTable.read(str(events_filename_MC), hdu=4)
    #Effective area used to simulate the MC. Should be in m2, it would be great to have it directly store with a unit in the colunm in order to be abble to use astropy units
    Amc=math.pi*(table_MC["CORE_MAX"][0]**2-table_MC["CORE_MIN"][0]**2)
    # Determine the flux of the source of the MC simulation from the MC simulation effective area and the livetime assumed for the fake observation
    flux_int_simulated=(Nsimulated/(Amc*livetime)).to("cm^-2 s-1")
    eref=Quantity(1,"TeV")
    #Real spectral index used in the MC simulation
    gamma_simulated=-table_MC["INDEX"][0].value
    #You have a divergence in the intregral if the spectral index is exactly 2
    if gamma_simulated!=1:
        inter=eref*((emax/eref)**(1-gamma_simulated)-(emin/eref)**(1-gamma_simulated))/((1-gamma_simulated))
    else:
        inter=np.log(emax/emin)
    #Useful if you want to simulate a spectral law that is different from the one of the MC simulation
    if loi_spectrale=="PWL":
        proba=(table["MC_ENERGY"]/eref)**(-float(gamma_input))/(table["MC_ENERGY"]/eref)**(-gamma_simulated)
    elif loi_spectrale=="EXP":
        proba=((table["MC_ENERGY"]/eref)**(-float(gamma_input))*np.exp(-Quantity(beta_input,"TeV^-1")*table["MC_ENERGY"]))/(table["MC_ENERGY"]/eref)**(-gamma_simulated)
    else:
        print("you didn't give a valid spectral law")
    # Determine the flux of the MC source in the fake observation taking the number of events of the triggered list you used to generate the MC source
    n_events_to_draw=int(arg.n_events_to_draw)
    flux_1TeV_simulated=(flux_int_simulated/inter) *(n_events_to_draw/proba.sum())
    flux_1Crab_1TeV=Quantity(3.45e-11,"cm^-2 s^-1")
    percent_flux_Crab_simulated=flux_1TeV_simulated/flux_1Crab_1TeV


    #Remove the events from the real source in the FOV, remove the events located in a circle of 0.2 degree radius around the real source
    source_pos=SkyCoord(table_data.meta["RA_OBJ"],table_data.meta["DEC_OBJ"], unit="deg")
    events_pos=SkyCoord(table_data["RA"],table_data["DEC"], unit="deg")
    i_events_remove=np.where(events_pos.separation(source_pos)<Angle(0.2,"deg"))[0]
    table_data.remove_rows(i_events_remove)
    #Determine the position of the false source from the one of the triggered events
    RA_PNT=Angle(table_data.meta["RA_PNT"],"deg")
    DEC_PNT=Angle(table_data.meta["DEC_PNT"],"deg")
    #Transformation of coordinates to put the fake MC source in the real observation at the right offset in the FOV
    ra=RA_PNT-table_data_MC["SKYX_RADEC"]
    dec=DEC_PNT-table_data_MC["SKYY_RADEC"]
    table_data_MC["RA"]=ra
    table_data_MC["DEC"]=dec
    #keywords for the obs table of the fake observation
    table_data.meta["DEC_OBJ"]=np.median(table_data_MC["DEC"]).value
    table_data.meta["RA_OBJ"]=np.median(table_data_MC["RA"]).value
    table_data.meta["LIVETIME"]=livetime.to("s").value
    table_data.meta["ONTIME"]=livetime.to("s").value
    #Select the number of trigerred events to create the MC sourcee. Add a probability if we want to change the spectral law from the MC simulation
    for ns in range(Nsimus):
        index_events_MC=np.random.choice(np.arange(0,Ntrigered,1),n_events_to_draw,replace=False,p=proba/proba.sum())
        new_events_MC_table=Table(table_data_MC[index_events_MC])
        #Create the new events list table "new_data_table" from the MC events table and the real observation event table. Here, we already remove the events around the real source from the real osbervation table, only the background events are present in the observation table.
        new_data_table=vstack([new_events_MC_table,Table(table_data)])
        if loi_spectrale=="PWL":
            outdir=indir_MC+"/MC_simus/gamma_"+str(gamma_input)+"_nevents_"+str(n_events_to_draw)+"_withIRFMC/Nsimus_"+str(ns)
            outdir2=indir_MC+"/MC_simus/gamma_"+str(gamma_input)+"_nevents_"+str(n_events_to_draw)+"_withIRFMC/Nsimus_"+str(ns)+"/"+str(RealObservation.folder())
        elif loi_spectrale=="EXP":
            outdir=indir_MC+"/MC_simus/gamma_"+str(gamma_input)+"_beta_"+str(beta_input)+"_nevents_"+str(n_events_to_draw)+"_withIRFMC/Nsimus_"+str(ns)
            outdir2=indir_MC+"/MC_simus/gamma_"+str(gamma_input)+"_beta_"+str(beta_input)+"_nevents_"+str(n_events_to_draw)+"_withIRFMC/Nsimus_"+str(ns)+"/"+str(RealObservation.folder())
        try:
            os.makedirs(outdir2)
        except Exception:
            pass
        #Write the new obs table and the hdu table for the fake observation
        #I take directly the one of the real HESS observation and I did just some modifications of keyword above to match the fake MC source
        obstable=Table(table_obs_realdata)
        obstable["RA_OBJ"]= new_data_table.meta["RA_OBJ"]
        obstable["DEC_OBJ"]= new_data_table.meta["DEC_OBJ"]
        obstable.write(outdir+"/obs-index.fits.gz", overwrite=True)
        hdu_table=Table.read(indir_data+"/hdu-index.fits.gz")
        i_select=np.where(hdu_table["OBS_ID"]==obs_id)[0]
        hdu_table[i_select].write(outdir+"/hdu-index.fits.gz", overwrite=True)
        #Write the events fits file for each fake observation located in different folders for each observation
        primary_hdu=fits.open(str(events_filename_data))[0]
        hdu1=table_to_hdu(new_data_table)
        hdu2=table_to_hdu(Table.read(str(events_filename_data), hdu=2))
        hdu3=table_to_hdu(Table.read(str(events_filename_data), hdu=3))
        hdu4=table_to_hdu(Table.read(str(events_filename_data), hdu=4))
        hdulist=fits.HDUList([primary_hdu,hdu1,hdu2,hdu3,hdu4])
        hdulist.writeto(outdir+"/"+str(RealObservation.filename('events', format="old")),clobber=True)
        # Creating links for each fake observation on the IRFs of the MC simulation.
        a=os.system("ln -s "+str(aeff_filename)+" "+outdir+"/"+str(RealObservation.filename('aeff', format="old")))
        if a==256:
            os.system("unlink "+ outdir+"/"+str(RealObservation.filename('aeff', format="old")))
            os.system("ln -s "+str(aeff_filename)+" "+outdir+"/"+str(RealObservation.filename('aeff', format="old")))
        a=os.system("ln -s "+str(edisp_filename)+" "+outdir+"/"+str(RealObservation.filename('edisp', format="old")))
        if a==256:
            os.system("unlink "+ outdir+"/"+str(RealObservation.filename('edisp', format="old")))
            os.system("ln -s "+str(edisp_filename)+" "+outdir+"/"+str(RealObservation.filename('edisp', format="old")))
        a=os.system("ln -s "+str(psf_filename)+" "+outdir+"/"+str(RealObservation.filename('psf_table', format="old")))
        if a==256:
            os.system("unlink "+ outdir+"/"+str(RealObservation.filename('psf_table', format="old")))
            os.system("ln -s "+str(psf_filename)+" "+outdir+"/"+str(RealObservation.filename('psf_table', format="old")))
